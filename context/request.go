// Copyright 2019 asana Author. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package context

import (
	"bytes"
	"compress/gzip"
	"errors"
	"io"
	"io/ioutil"
	"net"
	"net/http"
	"net/url"
	"reflect"
	"strconv"
	"strings"

	"github.com/goasana/asana/session"
)

var maxParam = 50

// AsanaRequest operates the http request header, data, cookie and body.
// it also contains router params and current session.
type AsanaRequest struct {
	Context       *Context
	CruSession    session.Store
	pnames        []string
	pvalues       []string
	data          map[interface{}]interface{} // store some values in this context when calling context in filter or controller.
	RequestBody   []byte
	RunMethod     string
	RunController reflect.Type
}

// NewRequest return AsanaRequest generated by Context.
func NewRequest() *AsanaRequest {
	return &AsanaRequest{
		pnames:  make([]string, 0, maxParam),
		pvalues: make([]string, 0, maxParam),
		data:    make(map[interface{}]interface{}),
	}
}

// Reset init the AsanaRequest
func (request *AsanaRequest) Reset(ctx *Context) {
	request.Context = ctx
	request.CruSession = nil
	request.pnames = request.pnames[:0]
	request.pvalues = request.pvalues[:0]
	request.data = nil
	request.RequestBody = []byte{}
}

// Protocol returns request protocol name, such as HTTP/1.1 .
func (request *AsanaRequest) Protocol() string {
	return request.Context.HTTPRequest.Proto
}

// URI returns full request url with query string, fragment.
func (request *AsanaRequest) URI() string {
	return request.Context.HTTPRequest.RequestURI
}

// URL returns request url path (without query string, fragment).
func (request *AsanaRequest) URL() string {
	return request.Context.HTTPRequest.URL.Path
}

// Site returns base site url as scheme://domain type.
func (request *AsanaRequest) Site() string {
	return request.Scheme() + "://" + request.Domain()
}

// Scheme returns request scheme as "http" or "https".
func (request *AsanaRequest) Scheme() string {
	if scheme := request.Header(HeaderXForwardedProto); scheme != "" {
		return scheme
	}
	if request.Context.HTTPRequest.URL.Scheme != "" {
		return request.Context.HTTPRequest.URL.Scheme
	}
	if request.Context.HTTPRequest.TLS == nil {
		return "http"
	}
	return "https"
}

// Domain returns host name.
// Alias of Host method.
func (request *AsanaRequest) Domain() string {
	return request.Host()
}

// Host returns host name.
// if no host info in request, return localhost.
func (request *AsanaRequest) Host() string {
	if request.Context.HTTPRequest.Host != "" {
		if hostPart, _, err := net.SplitHostPort(request.Context.HTTPRequest.Host); err == nil {
			return hostPart
		}
		return request.Context.HTTPRequest.Host
	}
	return "localhost"
}

// Method returns http request method.
func (request *AsanaRequest) Method() string {
	return request.Context.HTTPRequest.Method
}

// Is returns boolean of this request is on given method, such as Is("POST").
func (request *AsanaRequest) Is(method string) bool {
	return request.Method() == method
}

// IsGet Is this a GET method request?
func (request *AsanaRequest) IsGet() bool {
	return request.Is("GET")
}

// IsPost Is this a POST method request?
func (request *AsanaRequest) IsPost() bool {
	return request.Is("POST")
}

// IsHead Is this a Head method request?
func (request *AsanaRequest) IsHead() bool {
	return request.Is("HEAD")
}

// IsOptions Is this a OPTIONS method request?
func (request *AsanaRequest) IsOptions() bool {
	return request.Is("OPTIONS")
}

// IsPut Is this a PUT method request?
func (request *AsanaRequest) IsPut() bool {
	return request.Is("PUT")
}

// IsDelete Is this a DELETE method request?
func (request *AsanaRequest) IsDelete() bool {
	return request.Is("DELETE")
}

// IsPatch Is this a PATCH method request?
func (request *AsanaRequest) IsPatch() bool {
	return request.Is("PATCH")
}

// IsAjax returns boolean of this request is generated by ajax.
func (request *AsanaRequest) IsAjax() bool {
	return request.Header(HeaderXRequestedWith) == "XMLHttpRequest"
}

// IsSecure returns boolean of this request is in https.
func (request *AsanaRequest) IsSecure() bool {
	return request.Scheme() == "https"
}

// IsWebsocket returns boolean of this request is in webSocket.
func (request *AsanaRequest) IsWebsocket() bool {
	return request.Header("Upgrade") == "websocket"
}

// IsUpload returns boolean of whether file uploads in this request or not..
func (request *AsanaRequest) IsUpload() bool {
	return someAccept(request.Header(HeaderContentType), "multipart/form-data")
}

// AcceptsHTML Checks if request accepts html response
func (request *AsanaRequest) AcceptsHTML() bool {
	return someAccept(request.Header(HeaderAccept), ApplicationHTML, TextHTML)
}

// AcceptsXML Checks if request accepts xml response
func (request *AsanaRequest) AcceptsXML() bool {
	return someAccept(request.Header(HeaderAccept), ApplicationXML, TextXML)
}

// AcceptsJSON Checks if request accepts json response
func (request *AsanaRequest) AcceptsJSON() bool {
	return someAccept(request.Header(HeaderAccept), ApplicationJSON)
}

// AcceptsJSONP Checks if request accepts jsonp response
func (request *AsanaRequest) AcceptsJSONP() bool {
	return someAccept(request.Header(HeaderAccept), ApplicationJSONP)
}

// AcceptsYAML Checks if request accepts yaml response
func (request *AsanaRequest) AcceptsYAML() bool {
	return someAccept(request.Header(HeaderAccept), ApplicationYAML)
}

// AcceptsProtoBuf Checks if request accepts protobuf response
func (request *AsanaRequest) AcceptsProtoBuf() bool {
	return someAccept(request.Header(HeaderAccept), ApplicationProtoBuf)
}

// Check if some of types is accepted by head
func someAccept(acceptHead string, acceptedTypes ...string) bool {
	for _, acceptedType := range acceptedTypes {
		if strings.Contains(strings.ToLower(acceptHead), strings.ToLower(acceptedType)) {
			return true
		}
	}

	return false
}

// IP returns request client ip.
// if in proxy, return first proxy id.
// if error, return RemoteAddr.
func (request *AsanaRequest) IP() string {
	ips := request.Proxy()
	if len(ips) > 0 && ips[0] != "" {
		rip, _, err := net.SplitHostPort(ips[0])
		if err != nil {
			rip = ips[0]
		}
		return rip
	}
	if ip, _, err := net.SplitHostPort(request.Context.HTTPRequest.RemoteAddr); err == nil {
		return ip
	}
	return request.Context.HTTPRequest.RemoteAddr
}

// Proxy returns proxy client ips slice.
func (request *AsanaRequest) Proxy() []string {
	if ips := request.Header(HeaderXForwardedFor); ips != "" {
		return strings.Split(ips, ",")
	}
	return []string{}
}

// Referer returns http referer header.
func (request *AsanaRequest) Referer() string {
	return request.Header(HeaderReferer)
}

// Refer returns http referer header.
func (request *AsanaRequest) Refer() string {
	return request.Referer()
}

// SubDomains returns sub domain string.
// if aa.bb.domain.com, returns aa.bb .
func (request *AsanaRequest) SubDomains() string {
	parts := strings.Split(request.Host(), ".")
	if len(parts) >= 3 {
		return strings.Join(parts[:len(parts)-2], ".")
	}
	return ""
}

// Port returns request client port.
// when error or empty, return 80.
func (request *AsanaRequest) Port() int {
	if _, portPart, err := net.SplitHostPort(request.Context.HTTPRequest.Host); err == nil {
		port, _ := strconv.Atoi(portPart)
		return port
	}
	return 80
}

// UserAgent returns request client user agent string.
func (request *AsanaRequest) UserAgent() string {
	return request.Header(HeaderUserAgent)
}

// ParamsLen return the length of the params
func (request *AsanaRequest) ParamsLen() int {
	return len(request.pnames)
}

// Param returns router param by a given key.
func (request *AsanaRequest) Param(key string) string {
	for i, v := range request.pnames {
		if v == key && i <= len(request.pvalues) {
			return request.pvalues[i]
		}
	}
	return ""
}

// Params returns the map[key]value.
func (request *AsanaRequest) Params() map[string]string {
	m := make(map[string]string)
	for i, v := range request.pnames {
		if i <= len(request.pvalues) {
			m[v] = request.pvalues[i]
		}
	}
	return m
}

// SetParam will set the param with key and value
func (request *AsanaRequest) SetParam(key, val string) {
	// check if already exists
	for i, v := range request.pnames {
		if v == key && i <= len(request.pvalues) {
			request.pvalues[i] = val
			return
		}
	}
	request.pvalues = append(request.pvalues, val)
	request.pnames = append(request.pnames, key)
}

// ResetParams clears any of the input's Params
// This function is used to clear parameters so they may be reset between filter
// passes.
func (request *AsanaRequest) ResetParams() {
	request.pnames = request.pnames[:0]
	request.pvalues = request.pvalues[:0]
}

// Query returns input data item string by a given string.
func (request *AsanaRequest) Query(key string) string {
	if val := request.Param(key); val != "" {
		return val
	}
	if request.Context.HTTPRequest.Form == nil {
		_ = request.Context.HTTPRequest.ParseForm()
	}
	return request.Context.HTTPRequest.Form.Get(key)
}

// Header returns request header item string by a given string.
// if non-existed, return empty string.
func (request *AsanaRequest) Header(key string) string {
	return request.Context.HTTPRequest.Header.Get(key)
}

// Cookie returns request cookie item string by a given key.
// if non-existed, return empty string.
func (request *AsanaRequest) Cookie(key string) string {
	ck, err := request.Context.HTTPRequest.Cookie(key)
	if err != nil {
		return ""
	}
	return ck.Value
}

// Session returns current session item value by a given key.
// if non-existed, return nil.
func (request *AsanaRequest) Session(key interface{}) interface{} {
	return request.CruSession.Get(key)
}

// CopyBody returns the raw request body data as bytes.
func (request *AsanaRequest) CopyBody(MaxMemory int64) []byte {
	if request.Context.HTTPRequest.Body == nil {
		return []byte{}
	}

	var requestBody []byte
	safe := &io.LimitedReader{R: request.Context.HTTPRequest.Body, N: MaxMemory}
	if request.Header(HeaderContentEncoding) == "gzip" {
		reader, err := gzip.NewReader(safe)
		if err != nil {
			return nil
		}
		requestBody, _ = ioutil.ReadAll(reader)
	} else {
		requestBody, _ = ioutil.ReadAll(safe)
	}

	_ = request.Context.HTTPRequest.Body.Close()
	bf := bytes.NewBuffer(requestBody)
	request.Context.HTTPRequest.Body = http.MaxBytesReader(request.Context.ResponseWriter, ioutil.NopCloser(bf), MaxMemory)
	request.RequestBody = requestBody
	return requestBody
}

// Data return the implicit data in the input
func (request *AsanaRequest) Data() map[interface{}]interface{} {
	if request.data == nil {
		request.data = make(map[interface{}]interface{})
	}
	return request.data
}

// GetData returns the stored data in this context.
func (request *AsanaRequest) GetData(key interface{}) interface{} {
	if v, ok := request.data[key]; ok {
		return v
	}
	return nil
}

// SetData stores data with given key in this context.
// This data are only available in this context.
func (request *AsanaRequest) SetData(key, val interface{}) {
	if request.data == nil {
		request.data = make(map[interface{}]interface{})
	}
	request.data[key] = val
}

// ParseFormOrMulitForm parseForm or parseMultiForm based on Content-type
func (request *AsanaRequest) ParseFormOrMulitForm(maxMemory int64) error {
	// Parse the body depending on the content type.
	if strings.Contains(request.Header(HeaderContentType), "multipart/form-data") {
		if err := request.Context.HTTPRequest.ParseMultipartForm(maxMemory); err != nil {
			return errors.New("Error parsing request body:" + err.Error())
		}
	} else if err := request.Context.HTTPRequest.ParseForm(); err != nil {
		return errors.New("Error parsing request body:" + err.Error())
	}
	return nil
}

// Bind data from request.Form[key] to dest
// like /?id=123&isok=true&ft=1.2&ol[0]=1&ol[1]=2&ul[]=str&ul[]=array&user.Name=asana
// var id int  asanaInput.Bind(&id, "id")  id ==123
// var isok bool  asanaInput.Bind(&isok, "isok")  isok ==true
// var ft float64  asanaInput.Bind(&ft, "ft")  ft ==1.2
// ol := make([]int, 0, 2)  asanaInput.Bind(&ol, "ol")  ol ==[1 2]
// ul := make([]string, 0, 2)  asanaInput.Bind(&ul, "ul")  ul ==[str array]
// user struct{Name}  asanaInput.Bind(&user, "user")  user == {Name:"asana"}
func (request *AsanaRequest) Bind(dest interface{}, key string) error {
	value := reflect.ValueOf(dest)
	if value.Kind() != reflect.Ptr {
		return errors.New("asana: non-pointer passed to Bind: " + key)
	}
	value = value.Elem()
	if !value.CanSet() {
		return errors.New("asana: non-settable variable passed to Bind: " + key)
	}
	typ := value.Type()
	// Get real type if dest define with interface{}.
	// e.g  var dest interface{} dest=1.0
	if value.Kind() == reflect.Interface {
		typ = value.Elem().Type()
	}
	rv := request.bind(key, typ)
	if !rv.IsValid() {
		return errors.New("asana: reflect value is empty")
	}
	value.Set(rv)
	return nil
}

func (request *AsanaRequest) bind(key string, typ reflect.Type) reflect.Value {
	if request.Context.HTTPRequest.Form == nil {
		_ = request.Context.HTTPRequest.ParseForm()
	}
	rv := reflect.Zero(typ)
	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		val := request.Query(key)
		if len(val) == 0 {
			return rv
		}
		rv = request.bindInt(val, typ)
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		val := request.Query(key)
		if len(val) == 0 {
			return rv
		}
		rv = request.bindUint(val, typ)
	case reflect.Float32, reflect.Float64:
		val := request.Query(key)
		if len(val) == 0 {
			return rv
		}
		rv = request.bindFloat(val, typ)
	case reflect.String:
		val := request.Query(key)
		if len(val) == 0 {
			return rv
		}
		rv = request.bindString(val, typ)
	case reflect.Bool:
		val := request.Query(key)
		if len(val) == 0 {
			return rv
		}
		rv = request.bindBool(val, typ)
	case reflect.Slice:
		rv = request.bindSlice(&request.Context.HTTPRequest.Form, key, typ)
	case reflect.Struct:
		rv = request.bindStruct(&request.Context.HTTPRequest.Form, key, typ)
	case reflect.Ptr:
		rv = request.bindPoint(key, typ)
	case reflect.Map:
		rv = request.bindMap(&request.Context.HTTPRequest.Form, key, typ)
	}
	return rv
}

func (request *AsanaRequest) bindValue(val string, typ reflect.Type) reflect.Value {
	rv := reflect.Zero(typ)
	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		rv = request.bindInt(val, typ)
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		rv = request.bindUint(val, typ)
	case reflect.Float32, reflect.Float64:
		rv = request.bindFloat(val, typ)
	case reflect.String:
		rv = request.bindString(val, typ)
	case reflect.Bool:
		rv = request.bindBool(val, typ)
	case reflect.Slice:
		rv = request.bindSlice(&url.Values{"": {val}}, "", typ)
	case reflect.Struct:
		rv = request.bindStruct(&url.Values{"": {val}}, "", typ)
	case reflect.Ptr:
		rv = request.bindPoint(val, typ)
	case reflect.Map:
		rv = request.bindMap(&url.Values{"": {val}}, "", typ)
	}
	return rv
}

func (request *AsanaRequest) bindInt(val string, typ reflect.Type) reflect.Value {
	intValue, err := strconv.ParseInt(val, 10, 64)
	if err != nil {
		return reflect.Zero(typ)
	}
	pValue := reflect.New(typ)
	pValue.Elem().SetInt(intValue)
	return pValue.Elem()
}

func (request *AsanaRequest) bindUint(val string, typ reflect.Type) reflect.Value {
	uintValue, err := strconv.ParseUint(val, 10, 64)
	if err != nil {
		return reflect.Zero(typ)
	}
	pValue := reflect.New(typ)
	pValue.Elem().SetUint(uintValue)
	return pValue.Elem()
}

func (request *AsanaRequest) bindFloat(val string, typ reflect.Type) reflect.Value {
	floatValue, err := strconv.ParseFloat(val, 64)
	if err != nil {
		return reflect.Zero(typ)
	}
	pValue := reflect.New(typ)
	pValue.Elem().SetFloat(floatValue)
	return pValue.Elem()
}

func (request *AsanaRequest) bindString(val string, typ reflect.Type) reflect.Value {
	return reflect.ValueOf(val)
}

func (request *AsanaRequest) bindBool(val string, typ reflect.Type) reflect.Value {
	val = strings.TrimSpace(strings.ToLower(val))
	switch val {
	case "true", "on", "1":
		return reflect.ValueOf(true)
	}
	return reflect.ValueOf(false)
}

type sliceValue struct {
	index int           // Index extracted from brackets.  If -1, no index was provided.
	value reflect.Value // the bound value for this slice element.
}

func (request *AsanaRequest) bindSlice(params *url.Values, key string, typ reflect.Type) reflect.Value {
	maxIndex := -1
	numNoIndex := 0
	var sliceValues []sliceValue
	for reqKey, vals := range *params {
		if !strings.HasPrefix(reqKey, key+"[") {
			continue
		}
		// Extract the index, and the index where a sub-key starts. (e.g. field[0].subkey)
		index := -1
		leftBracket, rightBracket := len(key), strings.Index(reqKey[len(key):], "]")+len(key)
		if rightBracket > leftBracket+1 {
			index, _ = strconv.Atoi(reqKey[leftBracket+1 : rightBracket])
		}
		subKeyIndex := rightBracket + 1

		// Handle the indexed case.
		if index > -1 {
			if index > maxIndex {
				maxIndex = index
			}
			sliceValues = append(sliceValues, sliceValue{
				index: index,
				value: request.bind(reqKey[:subKeyIndex], typ.Elem()),
			})
			continue
		}

		// It's an un-indexed element.  (e.g. element[])
		numNoIndex += len(vals)
		for _, val := range vals {
			// Unindexed values can only be direct-bound.
			sliceValues = append(sliceValues, sliceValue{
				index: -1,
				value: request.bindValue(val, typ.Elem()),
			})
		}
	}
	resultArray := reflect.MakeSlice(typ, maxIndex+1, maxIndex+1+numNoIndex)
	for _, sv := range sliceValues {
		if sv.index != -1 {
			resultArray.Index(sv.index).Set(sv.value)
		} else {
			resultArray = reflect.Append(resultArray, sv.value)
		}
	}
	return resultArray
}

func (request *AsanaRequest) bindStruct(params *url.Values, key string, typ reflect.Type) reflect.Value {
	result := reflect.New(typ).Elem()
	fieldValues := make(map[string]reflect.Value)
	for reqKey, val := range *params {
		var fieldName string
		if strings.HasPrefix(reqKey, key+".") {
			fieldName = reqKey[len(key)+1:]
		} else if strings.HasPrefix(reqKey, key+"[") && reqKey[len(reqKey)-1] == ']' {
			fieldName = reqKey[len(key)+1 : len(reqKey)-1]
		} else {
			continue
		}

		if _, ok := fieldValues[fieldName]; !ok {
			// Time to bind this field.  Get it and make sure we can set it.
			fieldValue := result.FieldByName(fieldName)
			if !fieldValue.IsValid() {
				continue
			}
			if !fieldValue.CanSet() {
				continue
			}
			boundVal := request.bindValue(val[0], fieldValue.Type())
			fieldValue.Set(boundVal)
			fieldValues[fieldName] = boundVal
		}
	}

	return result
}

func (request *AsanaRequest) bindPoint(key string, typ reflect.Type) reflect.Value {
	return request.bind(key, typ.Elem()).Addr()
}

func (request *AsanaRequest) bindMap(params *url.Values, key string, typ reflect.Type) reflect.Value {
	var (
		result    = reflect.MakeMap(typ)
		keyType   = typ.Key()
		valueType = typ.Elem()
	)
	for paramName, values := range *params {
		if !strings.HasPrefix(paramName, key+"[") || paramName[len(paramName)-1] != ']' {
			continue
		}

		key := paramName[len(key)+1 : len(paramName)-1]
		result.SetMapIndex(request.bindValue(key, keyType), request.bindValue(values[0], valueType))
	}
	return result
}
