// Copyright 2019 asana Author. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package context

import (
	"bytes"
	"compress/gzip"
	"errors"
	"io"
	"io/ioutil"
	"net"
	"net/http"
	"net/url"
	"reflect"
	"strconv"
	"strings"

	"github.com/beego/i18n"
)

var maxParam = 50

// Request methods of req
type Request interface {
	Header(head string) string
	GetLanguage(def ...string) string
	Reset(ctx *Context)
	Protocol() string
	URI() string
	URL() string
	Site() string
	Scheme() string
	Domain() string
	Host() string
	Method() string
	Is(method string) bool
	IsGet() bool
	IsPost() bool
	IsHead() bool
	IsOptions() bool
	IsPut() bool
	IsDelete() bool
	IsPatch() bool
	IsAjax() bool
	IsSecure() bool
	IsWebsocket() bool
	IsUpload() bool
	Accepts(contentTypes ...string) bool
	AcceptsHTML() bool
	AcceptsXML() bool
	AcceptsJSON() bool
	AcceptsJSONP() bool
	AcceptsYAML() bool
	AcceptsProtoBuf() bool
	IP() string
	Proxy() []string
	Referer() string
	Refer() string
	SubDomains() string
	Port() int
	UserAgent() string
	ParamsLen() int
	Param(key string) string
	Params() map[string]string
	SetParam(key, val string)
	ResetParams() Request
	Cookie(key string) string
	CopyBody(MaxMemory int64) []byte
	Data() map[interface{}]interface{}
	Query(key string) string
	GetFlash(key interface{}) interface{}
	SetFlash(key, val interface{})
	ParseFormOrMultiForm(maxMemory int64) error
	BindForm(dest interface{}, key string) error
}

// asanaRequest operates the http request header, data, cookie and body.
// it also contains router params and current session.
type asanaRequest struct {
	HTTPRequest   *http.Request
	Context       *Context
	pnames        []string
	pvalues       []string
	data          map[interface{}]interface{} // store some values in this context when calling context in filter or controller.
	RequestBody   []byte
	RunMethod     string
	RunController reflect.Type
}

var _ Request = (*asanaRequest)(nil)

// NewRequest return asanaRequest generated by Context.
func NewRequest() *asanaRequest {
	return &asanaRequest{
		pnames:  make([]string, 0, maxParam),
		pvalues: make([]string, 0, maxParam),
		data:    make(map[interface{}]interface{}),
	}
}

// GetJWT get token
func (req *asanaRequest) GetJWT() (string, error) {
	authHeader := req.Header(HeaderAuthorization)
	authHeaderParts := strings.Fields(authHeader)
	if len(authHeaderParts) != 2 || !isJWTHeader(authHeaderParts[0]) {
		return "", errors.New("authorization header format must be Bearer|JWT|Token {token}")
	}

	return authHeaderParts[1], nil
}

func isJWTHeader(header string) bool {
	for _, v := range strings.Fields("bearer jwt token") {
		if strings.ToLower(header) == v {
			return true
		}
	}
	return false
}

// GetLanguage get the language accepted
func (req *asanaRequest) GetLanguage(def ...string) string {
	al := req.Header(HeaderAcceptLanguage)

	var lang string
	if len(def) > 0 {
		lang = def[0]
	}

	if len(al) > 0 {
		if len(al) > 4 {
			if i18n.IsExist(al[:5]) {
				lang = al[:5]
			} else if i18n.IsExist(al[:2]) {
				lang = al[:2]
			}
		}
	}

	return lang
}

// Reset init the asanaRequest
func (req *asanaRequest) Reset(ctx *Context) {
	req.Context = ctx
	req.pnames = req.pnames[:0]
	req.pvalues = req.pvalues[:0]
	req.data = nil
	req.RequestBody = []byte{}
}

// Protocol returns request protocol name, such as HTTP/1.1 .
func (req *asanaRequest) Protocol() string {
	return req.Context.HTTPRequest.Proto
}

// URI returns full request url with query string, fragment.
func (req *asanaRequest) URI() string {
	return req.Context.HTTPRequest.RequestURI
}

// URL returns request url path (without query string, fragment).
func (req *asanaRequest) URL() string {
	return req.Context.HTTPRequest.URL.Path
}

// Site returns base site url as scheme://domain type.
func (req *asanaRequest) Site() string {
	return req.Scheme() + "://" + req.Domain()
}

// Scheme returns request scheme as "http" or "https".
func (req *asanaRequest) Scheme() string {
	if scheme := req.Header(HeaderXForwardedProto); scheme != "" {
		return scheme
	}
	if req.Context.HTTPRequest.URL.Scheme != "" {
		return req.Context.HTTPRequest.URL.Scheme
	}
	if req.Context.HTTPRequest.TLS == nil {
		return "http"
	}
	return "https"
}

// Domain returns host name.
// Alias of Host method.
func (req *asanaRequest) Domain() string {
	return req.Host()
}

// Host returns host name.
// if no host info in request, return localhost.
func (req *asanaRequest) Host() string {
	if req.Context.HTTPRequest.Host != "" {
		if hostPart, _, err := net.SplitHostPort(req.Context.HTTPRequest.Host); err == nil {
			return hostPart
		}
		return req.Context.HTTPRequest.Host
	}
	return "localhost"
}

// Method returns http request method.
func (req *asanaRequest) Method() string {
	return req.Context.HTTPRequest.Method
}

// Is returns boolean of this request is on given method, such as Is("POST").
func (req *asanaRequest) Is(method string) bool {
	return req.Method() == method
}

// IsGet Is this a GET method request?
func (req *asanaRequest) IsGet() bool {
	return req.Is("GET")
}

// IsPost Is this a POST method request?
func (req *asanaRequest) IsPost() bool {
	return req.Is("POST")
}

// IsHead Is this a Head method request?
func (req *asanaRequest) IsHead() bool {
	return req.Is("HEAD")
}

// IsOptions Is this a OPTIONS method request?
func (req *asanaRequest) IsOptions() bool {
	return req.Is("OPTIONS")
}

// IsPut Is this a PUT method request?
func (req *asanaRequest) IsPut() bool {
	return req.Is("PUT")
}

// IsDelete Is this a DELETE method request?
func (req *asanaRequest) IsDelete() bool {
	return req.Is("DELETE")
}

// IsPatch Is this a PATCH method request?
func (req *asanaRequest) IsPatch() bool {
	return req.Is("PATCH")
}

// IsAjax returns boolean of this request is generated by ajax.
func (req *asanaRequest) IsAjax() bool {
	return req.Header(HeaderXRequestedWith) == "XMLHttpRequest"
}

// IsSecure returns boolean of this request is in https.
func (req *asanaRequest) IsSecure() bool {
	return req.Scheme() == "https"
}

// IsWebsocket returns boolean of this request is in webSocket.
func (req *asanaRequest) IsWebsocket() bool {
	return req.Header("Upgrade") == "websocket"
}

// IsUpload returns boolean of whether file uploads in this request or not..
func (req *asanaRequest) IsUpload() bool {
	return someAccept(req.Header(HeaderContentType), "multipart/form-data")
}

// AcceptsHTML Checks if request accepts html response
func (req *asanaRequest) Accepts(contentTypes ...string) bool {
	return someAccept(req.Header(HeaderAccept), contentTypes...)
}

// AcceptsHTML Checks if request accepts html response
func (req *asanaRequest) AcceptsHTML() bool {
	return req.Accepts(ApplicationHTML, TextHTML)
}

// AcceptsXML Checks if request accepts xml response
func (req *asanaRequest) AcceptsXML() bool {
	return req.Accepts(ApplicationXML, TextXML)
}

// AcceptsJSON Checks if request accepts json response
func (req *asanaRequest) AcceptsJSON() bool {
	return req.Accepts(ApplicationJSON)
}

// AcceptsMSGPACK Checks if request accepts msgpack response
func (req *asanaRequest) AcceptsMSGPACK() bool {
	return req.Accepts(ApplicationMSGPack)
}

// AcceptsJSONP Checks if request accepts jsonp response
func (req *asanaRequest) AcceptsJSONP() bool {
	return req.Accepts(ApplicationJSONP)
}

// AcceptsYAML Checks if request accepts yaml response
func (req *asanaRequest) AcceptsYAML() bool {
	return req.Accepts(ApplicationYAML)
}

// AcceptsProtoBuf Checks if request accepts protobuf response
func (req *asanaRequest) AcceptsProtoBuf() bool {
	return req.Accepts(ApplicationProtoBuf)
}

// Check if some of types is accepted by head
func someAccept(acceptHead string, acceptedTypes ...string) bool {
	for _, acceptedType := range acceptedTypes {
		if strings.Contains(strings.ToLower(acceptHead), strings.ToLower(acceptedType)) {
			return true
		}
	}

	return false
}

// IP returns request client ip.
// if in proxy, return first proxy id.
// if error, return RemoteAddr.
func (req *asanaRequest) IP() string {
	ips := req.Proxy()
	if len(ips) > 0 && ips[0] != "" {
		rip, _, err := net.SplitHostPort(ips[0])
		if err != nil {
			rip = ips[0]
		}
		return rip
	}
	if ip, _, err := net.SplitHostPort(req.Context.HTTPRequest.RemoteAddr); err == nil {
		return ip
	}
	return req.Context.HTTPRequest.RemoteAddr
}

// Proxy returns proxy client ips slice.
func (req *asanaRequest) Proxy() []string {
	if ips := req.Header(HeaderXForwardedFor); ips != "" {
		return strings.Split(ips, ",")
	}
	return []string{}
}

// Referer returns http referer header.
func (req *asanaRequest) Referer() string {
	return req.Header(HeaderReferer)
}

// Refer returns http referer header.
func (req *asanaRequest) Refer() string {
	return req.Referer()
}

// SubDomains returns sub domain string.
// if aa.bb.domain.com, returns aa.bb .
func (req *asanaRequest) SubDomains() string {
	parts := strings.Split(req.Host(), ".")
	if len(parts) >= 3 {
		return strings.Join(parts[:len(parts)-2], ".")
	}
	return ""
}

// Port returns request client port.
// when error or empty, return 80.
func (req *asanaRequest) Port() int {
	if _, portPart, err := net.SplitHostPort(req.Context.HTTPRequest.Host); err == nil {
		port, _ := strconv.Atoi(portPart)
		return port
	}
	return 80
}

// UserAgent returns request client user agent string.
func (req *asanaRequest) UserAgent() string {
	return req.Header(HeaderUserAgent)
}

// ParamsLen return the length of the params
func (req *asanaRequest) ParamsLen() int {
	return len(req.pnames)
}

// Param returns router param by a given key.
func (req *asanaRequest) Param(key string) string {
	for i, v := range req.pnames {
		if v == key && i <= len(req.pvalues) {
			return req.pvalues[i]
		}
	}
	return ""
}

// Params returns the map[key]value.
func (req *asanaRequest) Params() map[string]string {
	m := make(map[string]string)
	for i, v := range req.pnames {
		if i <= len(req.pvalues) {
			m[v] = req.pvalues[i]
		}
	}
	return m
}

// SetParam will set the param with key and value
func (req *asanaRequest) SetParam(key, val string) {
	// check if already exists
	for i, v := range req.pnames {
		if v == key && i <= len(req.pvalues) {
			req.pvalues[i] = val
			return
		}
	}
	req.pvalues = append(req.pvalues, val)
	req.pnames = append(req.pnames, key)
}

// ResetParams clears any of the input's Params
// This function is used to clear parameters so they may be reset between filter
// passes.
func (req *asanaRequest) ResetParams() Request {
	req.pnames = req.pnames[:0]
	req.pvalues = req.pvalues[:0]
	return req
}

// Query returns input data item string by a given string.
func (req *asanaRequest) Query(key string) string {
	if val := req.Param(key); val != "" {
		return val
	}
	if req.Context.HTTPRequest.Form == nil {
		_ = req.Context.HTTPRequest.ParseForm()
	}
	return req.Context.HTTPRequest.Form.Get(key)
}

// Header returns request header item string by a given string.
// if non-existed, return empty string.
func (req *asanaRequest) Header(key string) string {
	return req.Context.HTTPRequest.Header.Get(key)
}

// Cookie returns request cookie item string by a given key.
// if non-existed, return empty string.
func (req *asanaRequest) Cookie(key string) string {
	ck, err := req.Context.HTTPRequest.Cookie(key)
	if err != nil {
		return ""
	}
	return ck.Value
}

// CopyBody returns the raw request body data as bytes.
func (req *asanaRequest) CopyBody(MaxMemory int64) []byte {
	if req.Context.HTTPRequest.Body == nil {
		return []byte{}
	}

	var requestBody []byte
	safe := &io.LimitedReader{R: req.Context.HTTPRequest.Body, N: MaxMemory}
	if req.Header(HeaderContentEncoding) == "gzip" {
		reader, err := gzip.NewReader(safe)
		if err != nil {
			return nil
		}
		requestBody, _ = ioutil.ReadAll(reader)
	} else {
		requestBody, _ = ioutil.ReadAll(safe)
	}

	_ = req.Context.HTTPRequest.Body.Close()
	bf := bytes.NewBuffer(requestBody)
	req.Context.HTTPRequest.Body = http.MaxBytesReader(req.Context.ResponseWriter, ioutil.NopCloser(bf), MaxMemory)
	req.RequestBody = requestBody
	return requestBody
}

// data return the implicit data in the input
func (req *asanaRequest) Data() map[interface{}]interface{} {
	if req.data == nil {
		req.data = make(map[interface{}]interface{})
	}
	return req.data
}

// GetFlash returns the stored data in this context.
func (req *asanaRequest) GetFlash(key interface{}) interface{} {
	if v, ok := req.data[key]; ok {
		return v
	}
	return nil
}

// SetFlash stores data with given key in this context.
// This data are only available in this context.
func (req *asanaRequest) SetFlash(key, val interface{}) {
	if req.data == nil {
		req.data = make(map[interface{}]interface{})
	}
	req.data[key] = val
}

// ParseFormOrMultiForm parseForm or parseMultiForm based on Content-type
func (req *asanaRequest) ParseFormOrMultiForm(maxMemory int64) error {
	// Parse the body depending on the content type.
	if strings.Contains(req.Header(HeaderContentType), "multipart/form-data") {
		if err := req.Context.HTTPRequest.ParseMultipartForm(maxMemory); err != nil {
			return errors.New("Error parsing req body:" + err.Error())
		}
	} else if err := req.Context.HTTPRequest.ParseForm(); err != nil {
		return errors.New("Error parsing req body:" + err.Error())
	}
	return nil
}

// BindForm data from request.Form[key] to dest
// like /?id=123&isok=true&ft=1.2&ol[0]=1&ol[1]=2&ul[]=str&ul[]=array&user.Name=asana
// var id int  asanaInput.BindForm(&id, "id")  id ==123
// var isok bool  asanaInput.BindForm(&isok, "isok")  isok ==true
// var ft float64  asanaInput.BindForm(&ft, "ft")  ft ==1.2
// ol := make([]int, 0, 2)  asanaInput.BindForm(&ol, "ol")  ol ==[1 2]
// ul := make([]string, 0, 2)  asanaInput.BindForm(&ul, "ul")  ul ==[str array]
// user struct{Name}  asanaInput.BindForm(&user, "user")  user == {Name:"asana"}
func (req *asanaRequest) BindForm(dest interface{}, key string) error {
	value := reflect.ValueOf(dest)
	if value.Kind() != reflect.Ptr {
		return errors.New("asana: non-pointer passed to BindForm: " + key)
	}
	value = value.Elem()
	if !value.CanSet() {
		return errors.New("asana: non-settable variable passed to BindForm: " + key)
	}
	typ := value.Type()
	// Get real type if dest define with interface{}.
	// e.g  var dest interface{} dest=1.0
	if value.Kind() == reflect.Interface {
		typ = value.Elem().Type()
	}
	rv := req.bind(key, typ)
	if !rv.IsValid() {
		return errors.New("asana: reflect value is empty")
	}
	value.Set(rv)
	return nil
}

func (req *asanaRequest) bind(key string, typ reflect.Type) reflect.Value {
	if req.Context.HTTPRequest.Form == nil {
		_ = req.Context.HTTPRequest.ParseForm()
	}
	rv := reflect.Zero(typ)
	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		val := req.Query(key)
		if len(val) == 0 {
			return rv
		}
		rv = req.bindInt(val, typ)
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		val := req.Query(key)
		if len(val) == 0 {
			return rv
		}
		rv = req.bindUint(val, typ)
	case reflect.Float32, reflect.Float64:
		val := req.Query(key)
		if len(val) == 0 {
			return rv
		}
		rv = req.bindFloat(val, typ)
	case reflect.String:
		val := req.Query(key)
		if len(val) == 0 {
			return rv
		}
		rv = req.bindString(val, typ)
	case reflect.Bool:
		val := req.Query(key)
		if len(val) == 0 {
			return rv
		}
		rv = req.bindBool(val, typ)
	case reflect.Slice:
		rv = req.bindSlice(&req.Context.HTTPRequest.Form, key, typ)
	case reflect.Struct:
		rv = req.bindStruct(&req.Context.HTTPRequest.Form, key, typ)
	case reflect.Ptr:
		rv = req.bindPoint(key, typ)
	case reflect.Map:
		rv = req.bindMap(&req.Context.HTTPRequest.Form, key, typ)
	}
	return rv
}

func (req *asanaRequest) bindValue(val string, typ reflect.Type) reflect.Value {
	rv := reflect.Zero(typ)
	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		rv = req.bindInt(val, typ)
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		rv = req.bindUint(val, typ)
	case reflect.Float32, reflect.Float64:
		rv = req.bindFloat(val, typ)
	case reflect.String:
		rv = req.bindString(val, typ)
	case reflect.Bool:
		rv = req.bindBool(val, typ)
	case reflect.Slice:
		rv = req.bindSlice(&url.Values{"": {val}}, "", typ)
	case reflect.Struct:
		rv = req.bindStruct(&url.Values{"": {val}}, "", typ)
	case reflect.Ptr:
		rv = req.bindPoint(val, typ)
	case reflect.Map:
		rv = req.bindMap(&url.Values{"": {val}}, "", typ)
	}
	return rv
}

func (req *asanaRequest) bindInt(val string, typ reflect.Type) reflect.Value {
	intValue, err := strconv.ParseInt(val, 10, 64)
	if err != nil {
		return reflect.Zero(typ)
	}
	pValue := reflect.New(typ)
	pValue.Elem().SetInt(intValue)
	return pValue.Elem()
}

func (req *asanaRequest) bindUint(val string, typ reflect.Type) reflect.Value {
	uintValue, err := strconv.ParseUint(val, 10, 64)
	if err != nil {
		return reflect.Zero(typ)
	}
	pValue := reflect.New(typ)
	pValue.Elem().SetUint(uintValue)
	return pValue.Elem()
}

func (req *asanaRequest) bindFloat(val string, typ reflect.Type) reflect.Value {
	floatValue, err := strconv.ParseFloat(val, 64)
	if err != nil {
		return reflect.Zero(typ)
	}
	pValue := reflect.New(typ)
	pValue.Elem().SetFloat(floatValue)
	return pValue.Elem()
}

func (req *asanaRequest) bindString(val string, typ reflect.Type) reflect.Value {
	return reflect.ValueOf(val)
}

func (req *asanaRequest) bindBool(val string, typ reflect.Type) reflect.Value {
	val = strings.TrimSpace(strings.ToLower(val))
	switch val {
	case "true", "on", "1":
		return reflect.ValueOf(true)
	}
	return reflect.ValueOf(false)
}

type sliceValue struct {
	index int           // Index extracted from brackets.  If -1, no index was provided.
	value reflect.Value // the bound value for this slice element.
}

func (req *asanaRequest) bindSlice(params *url.Values, key string, typ reflect.Type) reflect.Value {
	maxIndex := -1
	numNoIndex := 0
	var sliceValues []sliceValue
	for reqKey, vals := range *params {
		if !strings.HasPrefix(reqKey, key+"[") {
			continue
		}
		// Extract the index, and the index where a sub-key starts. (e.g. field[0].subkey)
		index := -1
		leftBracket, rightBracket := len(key), strings.Index(reqKey[len(key):], "]")+len(key)
		if rightBracket > leftBracket+1 {
			index, _ = strconv.Atoi(reqKey[leftBracket+1 : rightBracket])
		}
		subKeyIndex := rightBracket + 1

		// Handle the indexed case.
		if index > -1 {
			if index > maxIndex {
				maxIndex = index
			}
			sliceValues = append(sliceValues, sliceValue{
				index: index,
				value: req.bind(reqKey[:subKeyIndex], typ.Elem()),
			})
			continue
		}

		// It's an un-indexed element.  (e.g. element[])
		numNoIndex += len(vals)
		for _, val := range vals {
			// Unindexed values can only be direct-bound.
			sliceValues = append(sliceValues, sliceValue{
				index: -1,
				value: req.bindValue(val, typ.Elem()),
			})
		}
	}
	resultArray := reflect.MakeSlice(typ, maxIndex+1, maxIndex+1+numNoIndex)
	for _, sv := range sliceValues {
		if sv.index != -1 {
			resultArray.Index(sv.index).Set(sv.value)
		} else {
			resultArray = reflect.Append(resultArray, sv.value)
		}
	}
	return resultArray
}

func (req *asanaRequest) bindStruct(params *url.Values, key string, typ reflect.Type) reflect.Value {
	result := reflect.New(typ).Elem()
	fieldValues := make(map[string]reflect.Value)
	for reqKey, val := range *params {
		var fieldName string
		if strings.HasPrefix(reqKey, key+".") {
			fieldName = reqKey[len(key)+1:]
		} else if strings.HasPrefix(reqKey, key+"[") && reqKey[len(reqKey)-1] == ']' {
			fieldName = reqKey[len(key)+1 : len(reqKey)-1]
		} else {
			continue
		}

		if _, ok := fieldValues[fieldName]; !ok {
			// Time to bind this field.  Get it and make sure we can set it.
			fieldValue := result.FieldByName(fieldName)
			if !fieldValue.IsValid() {
				continue
			}
			if !fieldValue.CanSet() {
				continue
			}
			boundVal := req.bindValue(val[0], fieldValue.Type())
			fieldValue.Set(boundVal)
			fieldValues[fieldName] = boundVal
		}
	}

	return result
}

func (req *asanaRequest) bindPoint(key string, typ reflect.Type) reflect.Value {
	return req.bind(key, typ.Elem()).Addr()
}

func (req *asanaRequest) bindMap(params *url.Values, key string, typ reflect.Type) reflect.Value {
	var (
		result    = reflect.MakeMap(typ)
		keyType   = typ.Key()
		valueType = typ.Elem()
	)
	for paramName, values := range *params {
		if !strings.HasPrefix(paramName, key+"[") || paramName[len(paramName)-1] != ']' {
			continue
		}

		key := paramName[len(key)+1 : len(paramName)-1]
		result.SetMapIndex(req.bindValue(key, keyType), req.bindValue(values[0], valueType))
	}
	return result
}
